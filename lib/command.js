// Generated by CoffeeScript 1.3.3
(function() {
  var coffee, commander, compile, csso, error, fs, isAppModule, isDirectory, isFile, isNodeModule, isRelativeModule, isUnsupportedNodeModule, minifyCSS, minifyJS, oj, pass, path, readFileSync, recurse, spaces, success, tabs, trimArgList, uglifyjs, verbose, vm, watch, _, _buildCache, _buildFileCache, _buildNativeCache, _cacheHooks, _cacheOrigs, _cacheToString, _clearRememberedAndHooks, _clearRequireCache, _commonPath, _createHook, _first, _getRequiresInSource, _hookRequire, _nativeModuleCode, _nodeModuleUnsupported, _nodeModulesSupported, _ojModuleCode, _remember, _remembered;

  vm = require('vm');

  commander = require('commander');

  fs = require('fs');

  coffee = require('coffee-script');

  oj = require('./oj');

  uglifyjs = require('uglify-js');

  csso = require('csso');

  path = require('path');

  _ = oj.__;

  module.exports = function() {
    var compileOptions, file, files, _i, _len, _results;
    commander.version('0.0.5').usage('[options] <file, ...>').option('-d, --debug', 'Turn on debug output (default: false)', false).option('-r, --recurse', 'Recurse into directories (default: off)', false).option('-o, --output <dir>', 'Directory to output all files to (default: .)', process.cwd()).option('-v, --verbose <level>', 'Turn on verbose output (default: 0)', 0).option('-w, --watch <dir,dir,...>', 'Directories to watch (default: off)', trimArgList).parse(process.argv);
    if (!isDirectory(commander.output)) {
      error("directory expected for --output option (" + commander.output + ")");
    }
    commander.files = commander.args;
    if (!_.isArray(commander.files) || commander.files.length === 0) {
      error('expecting one or more files');
    }
    if (commander.verbose === 'all') {
      commander.verbose = 4;
    }
    verbose(1, "options: ");
    verbose(1, "\tdebug: " + (commander.debug || false));
    if (commander.files) {
      verbose(1, "\tfiles: " + commander.files);
    }
    verbose(1, "\toutput: " + (commander.output || false));
    verbose(1, "\trecurse: " + (commander.recurse || false));
    if (commander.watch) {
      verbose(1, "\twatch: " + commander.watch);
    }
    verbose(1, "\tverbose: " + (commander.verbose || false));
    files = _.clone(commander.files);
    if (commander.recurse) {
      files = recurse(files);
    }
    compileOptions = {
      outputDir: commander.output
    };
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      _results.push(compile(file, compileOptions));
    }
    return _results;
  };

  compile = function(filePath, options) {
    var cache, cacheString, fileOut, outputDir;
    if (options == null) {
      options = {};
    }
    outputDir = options.outputDir || process.cwd();
    fileOut = path.join(outputDir, (path.basename(filePath, '.oj')) + '.html');
    verbose(1, "compiling " + filePath);
    _clearRequireCache();
    _hookRequire();
    require(path.join(process.cwd(), filePath));
    verbose(2, "building " + filePath);
    cache = _buildCache(_remembered);
    verbose(2, "serializing " + filePath);
    cacheString = _cacheToString(cache);
    verbose(1, "saving " + fileOut);
    return fs.writeFileSync(fileOut, cacheString);
  };

  watch = function(dir, options) {
    if (options == null) {
      options = {};
    }
    return verbose(1, "watching " + dir);
  };

  recurse = function(files) {
    return files;
  };

  error = function(message, exitCode) {
    if (exitCode == null) {
      exitCode = 1;
    }
    console.log('oj: ', message);
    return process.exit(exitCode);
  };

  success = function(message) {
    return error(message, 0);
  };

  tabs = function(count) {
    return Array(count + 1).join('\t');
  };

  spaces = function(count) {
    return Array(count + 1).join(' ');
  };

  verbose = function(level, message) {
    if (commander.verbose >= level) {
      return console.log("oj: " + (spaces(4 * (level - 1))) + message);
    }
  };

  isFile = function(filePath) {
    try {
      return (fs.statSync(filePath)).isFile();
    } catch (e) {
      return false;
    }
  };

  isDirectory = function(dirpath) {
    try {
      return (fs.statSync(dirpath)).isDirectory();
    } catch (e) {
      return false;
    }
  };

  readFileSync = function(filePath) {
    return fs.readFileSync(filePath, 'utf8');
  };

  _commonPath = function(moduleName, moduleParentPaths) {
    var p, _i, _len;
    if (!((moduleName != null) && _.isArray(moduleParentPaths))) {
      return null;
    }
    for (_i = 0, _len = moduleParentPaths.length; _i < _len; _i++) {
      p = moduleParentPaths[_i];
      if (_.startsWith(moduleName, p + '/')) {
        return p + '/';
      }
    }
    return null;
  };

  trimArgList = function(v) {
    return _.trim(v.split(','));
  };

  _.trim = function(any) {
    var out;
    if (_.isString(any)) {
      return any.trim();
    } else if (_.isArray(any)) {
      out = _.map(any, function(v) {
        return v.trim();
      });
      return _.reject(out, (function(v) {
        return v === '' || v === null;
      }));
    } else {
      return any;
    }
  };

  _.startsWith = function(strInput, strStart) {
    if (!((_.isString(strInput)) && (_.isString(strStart)))) {
      throw 'startsWith: argument error';
    }
    return strInput.length >= strStart.length && strInput.lastIndexOf(strStart, 0) === 0;
  };

  _.escapeSingleQuotes = function(str) {
    return str.replace(/'/g, "\\'");
  };

  minifyJS = function(filename, js, options) {
    if (options == null) {
      options = {};
    }
    verbose(4, "minifying " + filename);
    try {
      return js = uglifyjs(js, options);
    } catch (e) {
      console.log("oj.command: could not minify: " + filename);
      console.log(e);
      throw e;
    }
  };

  minifyCSS = function(filename, css, structureOff) {
    if (structureOff == null) {
      structureOff = false;
    }
    verbose(4, "minifying " + filename);
    try {
      return css = csso.justDoIt(css, structureOff);
    } catch (e) {
      console.log("oj.command: could not minify: " + filename);
      console.log(e);
      throw e;
    }
  };

  _remembered = {};

  _remember = function(remembered, filename, code, module) {
    if (code) {
      verbose(2, "requiring " + filename);
    }
    return remembered[filename] = _.defaults({
      code: code,
      module: module
    }, remembered[filename] || {});
  };

  _cacheHooks = {};

  _cacheOrigs = {};

  _hookRequire = function() {
    var ext, handlers, hook, _results;
    handlers = require.extensions;
    _results = [];
    for (ext in handlers) {
      hook = _cacheHooks[ext] || (_cacheHooks[ext] = _createHook(ext));
      if (handlers[ext] !== hook) {
        _cacheOrigs[ext] = handlers[ext];
        _results.push(handlers[ext] = hook);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _createHook = function(ext) {
    return function(module, filename) {
      var moduleCompile;
      if (!module.loaded) {
        _remember(_remembered, filename, null, module.paths);
        moduleCompile = module._compile;
        module._compile = function(code) {
          _remember(_remembered, filename, code, module.paths);
          return moduleCompile.apply(this, arguments);
        };
      }
      _cacheOrigs[ext](module, filename);
      return _hookRequire();
    };
  };

  _nodeModulesSupported = {
    assert: 1,
    console: 1,
    crypto: 1,
    events: 1,
    freelist: 1,
    path: 1,
    punycode: 1,
    querystring: 1,
    string_decoder: 1,
    tty: 1,
    url: 1,
    util: 1
  };

  _nodeModuleUnsupported = {
    child_process: 1,
    domain: 1,
    fs: 1,
    net: 1,
    os: 1,
    vm: 1
  };

  isNodeModule = function(module) {
    return !!_nodeModulesSupported[module];
  };

  isUnsupportedNodeModule = function(module) {
    return !!_nodeModuleUnsupported[module];
  };

  isAppModule = function(module) {
    return (module.indexOf('/')) === -1;
  };

  isRelativeModule = function(module) {
    return (module.indexOf('/')) !== -1;
  };

  _clearRequireCache = function() {
    return _clearRememberedAndHooks();
  };

  _clearRememberedAndHooks = function() {
    _remembered = {};
    _cacheHooks = {};
    return _cacheOrigs = {};
  };

  _getRequiresInSource = function(code) {
    var match, out, r;
    r = new RegExp("require\\s*\\(?\\s*[\"']([^\"']+)", 'g');
    out = [];
    while (match = r.exec(code)) {
      out.push(match[1]);
    }
    return out;
  };

  _first = function(array, fn) {
    var x, y, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      x = array[_i];
      y = fn(x);
      if (y) {
        return y;
      }
    }
  };

  _buildCache = function(remembered, cache) {
    var data, filename, pathComponents;
    if (cache == null) {
      cache = {
        modules: {},
        files: {},
        "native": {}
      };
    }
    for (filename in remembered) {
      data = remembered[filename];
      verbose(3, "building " + filename, !(data.code != null) ? data.code = stripBOM(readFileSync(filename)) : void 0);
      _buildFileCache(cache.files, filename, data.code, commander.debug);
      pathComponents = _first(module.parent.paths, function(prefix) {
        var moduleMain, moduleName, modulePath;
        if (_.startsWith(filename, prefix + path.sep)) {
          modulePath = (filename.slice(prefix.length + 1)).split(path.sep);
          moduleName = modulePath[0];
          moduleMain = modulePath.slice(1).join(path.sep);
          return {
            modulesDir: prefix,
            moduleName: moduleName,
            moduleMain: moduleMain,
            moduleParentPath: module.id
          };
        }
      });
      if (pathComponents) {
        if (!cache.modules[pathComponents.modulesDir]) {
          cache.modules[pathComponents.modulesDir] = {};
        }
        cache.modules[pathComponents.modulesDir][pathComponents.moduleName] = pathComponents.moduleMain;
      }
      _buildNativeCache(cache["native"], data.code, commander.debug);
    }
    return cache;
  };

  _buildFileCache = function(_filesCache, filename, code, isDebug) {
    if (isDebug) {
      verbose(4, "loading file " + filename);
    }
    if (!isDebug) {
      code = minifyJS(filename, code);
    }
    return _filesCache[filename] = code;
  };

  pass = 1;

  _buildNativeCache = function(_nativeCache, code, isDebug) {
    var codeModule, moduleName, moduleNameList;
    moduleNameList = _getRequiresInSource(code);
    while (moduleName = moduleNameList.shift()) {
      if (_nativeCache[moduleName]) {
        continue;
      }
      if (moduleName === 'oj') {
        _nativeCache.oj = _ojModuleCode(isDebug);
      } else if (isUnsupportedNodeModule(moduleName)) {
        pass;

      } else if (isNodeModule(moduleName)) {
        codeModule = _nativeModuleCode(moduleName, isDebug);
        _nativeCache[moduleName] = codeModule;
        moduleNameList = moduleNameList.concat(_getRequiresInSource(codeModule));
      } else {
        pass;

      }
    }
    return null;
  };

  _ojModuleCode = function(isDebug) {
    var code;
    if (isDebug) {
      verbose(4, "loading module oj");
    }
    code = readFileSync(path.join(__dirname, "../lib/oj.js"));
    if (!isDebug) {
      return code = minifyJS('oj', code);
    }
  };

  _nativeModuleCode = function(moduleName, isDebug) {
    var code;
    if (isDebug) {
      verbose(4, "loading module " + moduleName);
    }
    code = readFileSync(path.join(__dirname, "../modules/" + moduleName + ".js"));
    if (!isDebug) {
      return code = minifyJS(moduleName, code);
    }
  };

  _cacheToString = function(cache) {
    var code, filePath, initialFile, moduleDir, moduleMain, moduleName, nameToMain, output, _fileToString, _moduleToString, _nativeModuleToString, _ref, _ref1, _ref2;
    _moduleToString = function(moduleDir, moduleName, moduleMain) {
      moduleDir = _.escapeSingleQuotes(moduleDir);
      moduleName = _.escapeSingleQuotes(moduleName);
      moduleMain = _.escapeSingleQuotes(moduleMain);
      return "M['" + moduleDir + "'] = {'" + moduleName + "': '" + moduleMain + "'};\n";
    };
    _nativeModuleToString = function(moduleName, code) {
      moduleName = _.escapeSingleQuotes(moduleName);
      return "N['" + moduleName + "'] = (function(module){function(require){" + code + "})(requirer('" + moduleName + "'));});\n";
    };
    _fileToString = function(filePath, code) {
      filePath = _.escapeSingleQuotes(filePath);
      return "F['" + filePath + "'] = (function(module){function(require){" + code + "})(requirer('" + filePath + "'));});\n";
    };
    output = "<script>// oj v" + oj.version + "\n(function(){\nvar F = {}, M = {}, N = {};\n\n// # Export OJ manually\n// module = {exports:{}}\n// N['oj'](module)\n// window.oj = module.exports\n\nfunction resolve(m, f) {\n  var dir = path.dirname(f);\n\n  // Relative\n  if(!!m.match(/\\//)){return path.join(dir, m);}\n\n  // Native\n  else if (N[m])){return N[m];}\n\n  // App\n  //else {}\n}\n\nfunction requirer(file){\n  return function(module){\n    r = resolve(module, file);\n  };\n}\n";
    _ref = cache.modules;
    for (moduleDir in _ref) {
      nameToMain = _ref[moduleDir];
      for (moduleName in nameToMain) {
        moduleMain = nameToMain[moduleName];
        verbose(3, "serializing record `" + moduleDir + "/" + moduleName + "`");
        output += _moduleToString(moduleDir, moduleName, moduleMain);
      }
    }
    _ref1 = cache.files;
    for (filePath in _ref1) {
      code = _ref1[filePath];
      verbose(3, "serializing file `" + filePath + "`");
      output += _fileToString(filePath, code);
    }
    _ref2 = cache["native"];
    for (moduleName in _ref2) {
      code = _ref2[moduleName];
      verbose(3, "serializing module '" + moduleName + "'");
      output += _nativeModuleToString(moduleName, code);
    }
    initialFile = _.escapeSingleQuotes(process.cwd() + "/.");
    output += "\nwindow.require = requirer('" + initialFile + "');\nwindow.oj = require('oj');\n}).call(this);\n</script>\n";
    return output;
  };

}).call(this);
