// Generated by CoffeeScript 1.3.3
(function() {
  var coffee, commander, compile, csso, error, fs, fullPaths, isAppModule, isDirectory, isFile, isNodeModule, isRelativeModule, isUnsupportedNodeModule, ls, minifyCSS, minifyJS, oj, pass, path, readFileSync, recurseIf, relativePathWithEscaping, spaces, success, tabs, trimArgList, uglifyjs, usage, verbose, vm, watch, _, _buildFileCache, _buildNativeCache, _buildNativeCacheFromModuleList, _buildRequireCache, _cacheHooks, _cacheOrigs, _clearRequireCacheRecord, _commonPath, _createHook, _first, _getRequiresInSource, _hookRequire, _nativeModuleCode, _nodeModuleUnsupported, _nodeModulesSupported, _ojModuleCode, _rememberModule, _requireCache, _requireCacheToString, _restoreRequireCache, _saveRequireCache;

  vm = require('vm');

  commander = require('commander');

  fs = require('fs');

  coffee = require('coffee-script');

  oj = require('./oj');

  uglifyjs = require('uglify-js');

  csso = require('csso');

  path = require('path');

  _ = require('underscore');

  module.exports = function() {
    commander.version('0.0.5').usage('[options] <file, ...>').option('-d, --debug', 'Turn on debug output (default: false)', false).option('-o, --output <dir>', 'Directory to output all files to (default: .)', process.cwd()).option('-r, --recurse', 'Recurse into directories (default: off)', false).option('-v, --verbose <level>', 'Turn on verbose level 0-3 (default: 0)', 0).option('-m, --modules <modules>', 'List of modules to include', []).parse(process.argv);
    if (!isDirectory(commander.output)) {
      error("`" + commander.output + "` is not a directory");
    }
    commander.args = fullPaths(commander.args, process.cwd());
    if (!_.isArray(commander.args) || commander.args.length === 0) {
      usage();
    }
    return recurseIf(commander.recurse, commander.args, function(err, files) {
      var compileOptions, f, file, _i, _j, _len, _len1, _results;
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        f = files[_i];
        if (!isFile(f)) {
          error("`" + f + "` is not a file");
        }
      }
      if (commander.verbose === 'all') {
        commander.verbose = 3;
      }
      _clearRequireCacheRecord('underscore');
      compileOptions = {
        outputDir: commander.output,
        modules: commander.modules || [],
        debug: commander.debug || false
      };
      compileOptions.modules.push('oj');
      compileOptions.modules.push('path');
      _results = [];
      for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
        file = files[_j];
        _results.push(compile(file, compileOptions));
      }
      return _results;
    });
  };

  recurseIf = function(condition, paths, cb) {
    if (condition) {
      return ls(paths, function(err, results) {
        return cb(null, results.files);
      });
    } else {
      return cb(null, paths);
    }
  };

  compile = function(filePath, options) {
    var cache, fileOut, html, m, modules, ojml, outputDir, scriptHtml, _i, _len, _ref;
    if (options == null) {
      options = {};
    }
    outputDir = options.outputDir || process.cwd();
    fileOut = path.join(outputDir, (path.basename(filePath, '.oj')) + '.html');
    verbose(1, "compiling " + filePath);
    cache = {
      modules: {},
      files: {},
      "native": {}
    };
    modules = {};
    _hookRequire(modules);
    _saveRequireCache();
    _ref = options.modules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      if (isNodeModule(m)) {
        verbose(2, "included " + m);
        _buildNativeCacheFromModuleList(cache["native"], [m], options.debug);
      } else {
        require(m);
      }
    }
    ojml = require(filePath);
    html = (oj.compile({
      debug: options.debug
    }, ojml)).html;
    _restoreRequireCache();
    if (html.indexOf('<html') === -1) {
      error("<html> tag is missing (" + filePath + ")");
    }
    if (html.indexOf('<body') === -1) {
      error("<body> tag is missing (" + filePath + ")");
    }
    verbose(2, "building " + filePath);
    cache = _buildRequireCache(modules, cache);
    verbose(2, "serializing " + filePath);
    scriptHtml = _requireCacheToString(cache);
    html = _.insertAt(html, html.lastIndexOf('</body>'), scriptHtml);
    verbose(1, "saving " + fileOut);
    return fs.writeFileSync(fileOut, html);
  };

  watch = function(dir, options) {
    if (options == null) {
      options = {};
    }
    return verbose(1, "watching " + dir);
  };

  error = function(message, exitCode) {
    if (exitCode == null) {
      exitCode = 1;
    }
    console.log('\n  error:', message, "\n");
    return process.exit(exitCode);
  };

  success = function() {
    return process.exit(0);
  };

  usage = function(code) {
    if (code == null) {
      code = 0;
    }
    commander.help();
    return process.exit(code);
  };

  tabs = function(count) {
    return Array(count + 1).join('\t');
  };

  spaces = function(count) {
    return Array(count + 1).join(' ');
  };

  verbose = function(level, message) {
    if (commander.verbose >= level) {
      return console.log("" + (spaces(4 * (level - 1))) + message);
    }
  };

  isFile = function(filePath) {
    try {
      return (fs.statSync(filePath)).isFile();
    } catch (e) {
      return false;
    }
  };

  isDirectory = function(dirpath) {
    try {
      return (fs.statSync(dirpath)).isDirectory();
    } catch (e) {
      return false;
    }
  };

  relativePathWithEscaping = function(fullPath, relativeTo) {
    return _.escapeSingleQuotes('/' + path.relative(process.cwd(), fullPath));
  };

  fullPaths = function(relativePaths, dir) {
    return _.map(relativePaths, function(p) {
      return path.join(dir, p);
    });
  };

  ls = function(paths, cb, results) {
    var breakIfDone, fullpath, pending, _fn, _i, _len;
    if (results == null) {
      results = {
        files: [],
        directories: []
      };
    }
    pending = paths.length;
    breakIfDone = function() {
      if (pending === 0) {
        results.files = _.uniq(results.files);
        results.directories = _.uniq(results.directories);
        return cb(null, results);
      }
    };
    _fn = function(fullpath) {
      return fs.stat(fullpath, function(err, stat) {
        if (stat != null ? stat.isDirectory() : void 0) {
          return fs.readdir(fullpath, function(err_, paths_) {
            if (err_) {
              return cb(err_);
            }
            results.directories.push(fullpath);
            paths_ = fullPaths(paths_, fullpath);
            return ls(paths_, (function(err3, res) {
              return breakIfDone(--pending);
            }), results);
          });
        } else {
          results.files.push(fullpath);
          return breakIfDone(--pending);
        }
      });
    };
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      fullpath = paths[_i];
      _fn(fullpath);
    }
    return breakIfDone();
  };

  readFileSync = function(filePath) {
    return fs.readFileSync(filePath, 'utf8');
  };

  _commonPath = function(moduleName, moduleParentPaths) {
    var p, _i, _len;
    if (!((moduleName != null) && _.isArray(moduleParentPaths))) {
      return null;
    }
    for (_i = 0, _len = moduleParentPaths.length; _i < _len; _i++) {
      p = moduleParentPaths[_i];
      if (_.startsWith(moduleName, p + '/')) {
        return p + '/';
      }
    }
    return null;
  };

  trimArgList = function(v) {
    return _.trim(v.split(','));
  };

  _.trim = function(any) {
    var out;
    if (_.isString(any)) {
      return any.trim();
    } else if (_.isArray(any)) {
      out = _.map(any, function(v) {
        return v.trim();
      });
      return _.reject(out, (function(v) {
        return v === '' || v === null;
      }));
    } else {
      return any;
    }
  };

  _.startsWith = function(strInput, strStart) {
    if (!((_.isString(strInput)) && (_.isString(strStart)))) {
      throw 'startsWith: argument error';
    }
    return strInput.length >= strStart.length && strInput.lastIndexOf(strStart, 0) === 0;
  };

  _.escapeSingleQuotes = function(str) {
    return str.replace(/'/g, "\\'");
  };

  _.insertAt = function(str, ix, substr) {
    return str.slice(0, ix) + substr + str.slice(ix);
  };

  minifyJS = function(filename, js, options) {
    if (options == null) {
      options = {};
    }
    verbose(3, "minifying " + filename);
    try {
      return js = uglifyjs(js, options);
    } catch (e) {
      console.log("oj.command: could not minify: " + filename);
      console.log(e);
      throw e;
    }
  };

  minifyCSS = function(filename, css, structureOff) {
    if (structureOff == null) {
      structureOff = false;
    }
    verbose(3, "minifying " + filename);
    try {
      return css = csso.justDoIt(css, structureOff);
    } catch (e) {
      console.log("oj.command: could not minify: " + filename);
      console.log(e);
      throw e;
    }
  };

  _rememberModule = function(modules, filename, code, module) {
    if (code) {
      verbose(2, "found " + filename);
    }
    return modules[filename] = _.defaults({
      code: code,
      module: module
    }, modules[filename] || {});
  };

  _cacheHooks = {};

  _cacheOrigs = {};

  _hookRequire = function(modules) {
    var ext, handlers, hook, _results;
    handlers = require.extensions;
    _results = [];
    for (ext in handlers) {
      hook = _cacheHooks[ext] || (_cacheHooks[ext] = _createHook(ext, modules));
      if (handlers[ext] !== hook) {
        _cacheOrigs[ext] = handlers[ext];
        _results.push(handlers[ext] = hook);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _createHook = function(ext, modules) {
    return function(module, filename) {
      var moduleCompile;
      if (!module.loaded) {
        _rememberModule(modules, filename, null, module.paths);
        moduleCompile = module._compile;
        module._compile = function(code) {
          _rememberModule(modules, filename, code, module.paths);
          return moduleCompile.apply(this, arguments);
        };
      }
      _cacheOrigs[ext](module, filename);
      return _hookRequire(modules);
    };
  };

  _nodeModulesSupported = {
    oj: 1,
    assert: 1,
    console: 1,
    crypto: 1,
    events: 1,
    freelist: 1,
    path: 1,
    punycode: 1,
    querystring: 1,
    string_decoder: 1,
    tty: 1,
    url: 1,
    util: 1
  };

  _nodeModuleUnsupported = {
    child_process: 1,
    domain: 1,
    fs: 1,
    net: 1,
    os: 1,
    vm: 1,
    buffer: 1
  };

  isNodeModule = function(module) {
    return !!_nodeModulesSupported[module];
  };

  isUnsupportedNodeModule = function(module) {
    return !!_nodeModuleUnsupported[module];
  };

  isAppModule = function(module) {
    return (module.indexOf('/')) === -1;
  };

  isRelativeModule = function(module) {
    return (module.indexOf('/')) !== -1;
  };

  _requireCache = null;

  _saveRequireCache = function() {
    return _requireCache = _.clone(require.cache);
  };

  _restoreRequireCache = function() {
    return require.cache = _requireCache;
  };

  _clearRequireCacheRecord = function(record) {
    return delete require.cache[require.resolve(record)];
  };

  _getRequiresInSource = function(code) {
    var match, out, r;
    r = new RegExp("require\\s*\\(?\\s*[\"']([^\"']+)", 'g');
    out = [];
    while (match = r.exec(code)) {
      out.push(match[1]);
    }
    return out;
  };

  _first = function(array, fn) {
    var x, y, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      x = array[_i];
      y = fn(x);
      if (y) {
        return y;
      }
    }
  };

  _buildRequireCache = function(modules, cache) {
    var data, filename, pathComponents;
    for (filename in modules) {
      data = modules[filename];
      verbose(3, "building " + filename, !(data.code != null) ? data.code = stripBOM(readFileSync(filename)) : void 0);
      _buildFileCache(cache.files, filename, data.code, commander.debug);
      pathComponents = _first(module.parent.paths, function(prefix) {
        var moduleMain, moduleName, modulePath;
        if (_.startsWith(filename, prefix + path.sep)) {
          modulePath = (filename.slice(prefix.length + 1)).split(path.sep);
          moduleName = modulePath[0];
          moduleMain = modulePath.slice(1).join(path.sep);
          return {
            modulesDir: prefix,
            moduleName: moduleName,
            moduleMain: moduleMain,
            moduleParentPath: module.id
          };
        }
      });
      if (pathComponents) {
        if (!cache.modules[pathComponents.modulesDir]) {
          cache.modules[pathComponents.modulesDir] = {};
        }
        cache.modules[pathComponents.modulesDir][pathComponents.moduleName] = pathComponents.moduleMain;
      }
      _buildNativeCache(cache["native"], data.code, commander.debug);
    }
    delete cache.files[require.resolve('oj')];
    return cache;
  };

  _buildFileCache = function(_filesCache, filename, code, isDebug) {
    if (isDebug) {
      verbose(3, "loading file " + filename);
    }
    if (!isDebug) {
      code = minifyJS(filename, code);
    }
    return _filesCache[filename] = code;
  };

  pass = 1;

  _buildNativeCache = function(nativeCache, code, isDebug) {
    var moduleNameList;
    moduleNameList = _getRequiresInSource(code);
    return _buildNativeCacheFromModuleList(nativeCache, moduleNameList, isDebug);
  };

  _buildNativeCacheFromModuleList = function(nativeCache, moduleNameList, isDebug) {
    var codeModule, moduleName;
    while (moduleName = moduleNameList.shift()) {
      if (nativeCache[moduleName]) {
        continue;
      }
      if (moduleName === 'oj') {
        nativeCache.oj = _ojModuleCode(isDebug);
      } else if (isUnsupportedNodeModule(moduleName)) {
        pass;

      } else if (isNodeModule(moduleName)) {
        codeModule = _nativeModuleCode(moduleName, isDebug);
        nativeCache[moduleName] = codeModule;
        moduleNameList = moduleNameList.concat(_getRequiresInSource(codeModule));
      } else {
        pass;

      }
    }
    return null;
  };

  _ojModuleCode = function(isDebug) {
    var code;
    code = readFileSync(path.join(__dirname, "../lib/oj.js"));
    if (!isDebug) {
      code = minifyJS('oj', code);
    }
    return code;
  };

  _nativeModuleCode = function(moduleName, isDebug) {
    var code;
    if (isDebug) {
      verbose(3, "loading module " + moduleName);
    }
    code = readFileSync(path.join(__dirname, "../modules/" + moduleName + ".js"));
    if (!isDebug) {
      code = minifyJS(moduleName, code);
    }
    return code;
  };

  _requireCacheToString = function(cache) {
    var code, filePath, moduleDir, moduleName, nameToMain, output, _fileToString, _modulesToString, _nativeModuleToString, _ref, _ref1, _ref2;
    _modulesToString = function(moduleDir, nameToMain) {
      moduleDir = relativePathWithEscaping(moduleDir, process.cwd());
      return "M['" + moduleDir + "'] = " + (JSON.stringify(nameToMain)) + ";\n";
    };
    _nativeModuleToString = function(moduleName, code) {
      moduleName = _.escapeSingleQuotes(moduleName);
      if (!code) {
        console.log("moduleName is undefined: ", moduleName);
      }
      return "N['" + moduleName + "'] = (function(module,exports){(function(require,process,global,Buffer,__dirname,__filename){" + code + "})(requirer('/'),P,G,B,'/','" + moduleName + "');});\n";
    };
    _fileToString = function(filePath, code) {
      var fileDir, fileName;
      filePath = relativePathWithEscaping(filePath, process.cwd());
      fileDir = path.dirname(filePath);
      fileName = path.basename(filePath);
      return "F['" + filePath + "'] = (function(module,exports){(function(require,process,global,Buffer,__dirname,__filename){" + code + "})(requirer('" + filePath + "'),P,G,B,'" + fileDir + "','" + fileName + "');});\n";
    };
    output = "<script>\n// Generated by oj v" + oj.version + "\n(function(){\nvar F = {}, M = {}, N = {}, R = {}, P, G, B;\n\n// process\nvar P = {\n  cwd: function(){return '/';}\n\n}\n\n// global\nvar G = {\n\n}\n\n// Buffer\nvar B = {\n\n}\n\nfunction code(m, f) {\n\n  // Native\n  if (N[m]){return N[m];}\n\n  // Relative\n  if(!!m.match(/\\//)){return path.join(path.dirname(f), m);}\n\n  // App\n  //else {}\n}\n\nfunction requirer(file){\n  return function(module){\n    c = code(module, file);\n    var exports = {};\n    var module = {exports:exports};\n    c(module,exports);\n    R[module] = m = module.exports;\n    return m;\n  };\n}\n";
    _ref = cache.modules;
    for (moduleDir in _ref) {
      nameToMain = _ref[moduleDir];
      output += _modulesToString(moduleDir, nameToMain);
    }
    _ref1 = cache.files;
    for (filePath in _ref1) {
      code = _ref1[filePath];
      verbose(3, "serializing file `" + filePath + "`");
      output += _fileToString(filePath, code);
    }
    _ref2 = cache["native"];
    for (moduleName in _ref2) {
      code = _ref2[moduleName];
      verbose(3, "serializing module '" + moduleName + "'");
      output += _nativeModuleToString(moduleName, code);
    }
    output += "\nwindow.require = requirer('/');\nwindow.oj = require('oj');\n\n}).call(this);\n</script>";
    return output;
  };

}).call(this);
