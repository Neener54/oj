// Generated by CoffeeScript 1.3.3
(function() {
  var coffee, commander, compile, csso, error, fs, fullPaths, isAppModule, isDirectory, isFile, isNodeModule, isRelativeModule, isUnsupportedNodeModule, ls, minifyCSS, minifyCSSUnless, minifyJS, minifyJSUnless, minifySimpleJS, minifySimpleJSUnless, oj, pass, path, readFileSync, recurseIf, relativePathWithEscaping, spaces, success, tabs, trimArgList, uglifyjs, usage, verbose, vm, watch, _, _buildFileCache, _buildNativeCache, _buildNativeCacheFromModuleList, _buildRequireCache, _cacheHooks, _cacheOrigs, _clearRequireCacheRecord, _commonPath, _createHook, _escapeSingleQuotes, _first, _getRequiresInSource, _hookRequire, _insertAt, _length, _nativeModuleCode, _nodeModuleUnsupported, _nodeModulesSupported, _ojModuleCode, _rememberModule, _requireCache, _requireCacheToString, _restoreRequireCache, _saveRequireCache, _startsWith, _trim;

  vm = require('vm');

  commander = require('commander');

  fs = require('fs');

  coffee = require('coffee-script');

  oj = require('./oj');

  uglifyjs = require('uglify-js');

  csso = require('csso');

  path = require('path');

  _ = require('underscore');

  module.exports = function() {
    commander.version('0.0.5').usage('[options] <file, ...>').option('-d, --debug', 'Turn on debug output (default: false)', false).option('-o, --output <dir>', 'Directory to output all files to (default: .)', process.cwd()).option('-r, --recurse', 'Recurse into directories (default: off)', false).option('-v, --verbose <level>', 'Turn on verbose level 0-3 (default: 1)', 1).option('-m, --modules <modules>', 'List of modules to include', []).parse(process.argv);
    if (!isDirectory(commander.output)) {
      error("`" + commander.output + "` is not a directory");
    }
    commander.args = fullPaths(commander.args, process.cwd());
    if (!_.isArray(commander.args) || commander.args.length === 0) {
      usage();
    }
    return recurseIf(commander.recurse, commander.args, function(err, files) {
      var compileOptions, f, file, _i, _j, _len, _len1, _results;
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        f = files[_i];
        if (!isFile(f)) {
          error("`" + f + "` is not a file");
        }
      }
      if (commander.verbose === 'all') {
        commander.verbose = 3;
      }
      _clearRequireCacheRecord('underscore');
      compileOptions = {
        outputDir: commander.output,
        modules: commander.modules || [],
        debug: commander.debug || false
      };
      compileOptions.modules.push('oj');
      compileOptions.modules.push('path');
      _results = [];
      for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
        file = files[_j];
        _results.push(compile(file, compileOptions));
      }
      return _results;
    });
  };

  recurseIf = function(condition, paths, cb) {
    if (condition) {
      return ls(paths, function(err, results) {
        return cb(null, results.files);
      });
    } else {
      return cb(null, paths);
    }
  };

  compile = function(filePath, options) {
    var cache, cacheLength, fileOut, html, m, modules, ojml, outputDir, scriptHtml, _i, _len, _ref;
    if (options == null) {
      options = {};
    }
    outputDir = options.outputDir || process.cwd();
    fileOut = path.join(outputDir, (path.basename(filePath, '.oj')) + '.html');
    verbose(2, "compiling " + filePath);
    cache = {
      modules: {},
      files: {},
      "native": {}
    };
    modules = {};
    _hookRequire(modules);
    _saveRequireCache();
    _ref = options.modules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      if (isNodeModule(m)) {
        _buildNativeCacheFromModuleList(cache["native"], [m], options.debug);
        verbose(3, "found " + m);
      } else {
        require(m);
      }
    }
    ojml = require(filePath);
    html = (oj.compile({
      debug: options.debug
    }, ojml)).html;
    _restoreRequireCache();
    if (html.indexOf('<html') === -1) {
      error("<html> tag is missing (" + filePath + ")");
    }
    if (html.indexOf('<body') === -1) {
      error("<body> tag is missing (" + filePath + ")");
    }
    verbose(2, "caching " + filePath + " (" + (_length(modules)) + " files)");
    cache = _buildRequireCache(modules, cache);
    cacheLength = _length(cache.files) + _length(cache.modules) + _length(cache["native"]);
    verbose(2, "serializing " + filePath + " (" + cacheLength + " files)");
    scriptHtml = _requireCacheToString(cache, options.debug);
    html = _insertAt(html, html.lastIndexOf('</body>'), scriptHtml);
    verbose(1, "compiled " + fileOut);
    return fs.writeFileSync(fileOut, html);
  };

  watch = function(dir, options) {
    if (options == null) {
      options = {};
    }
    return verbose(1, "watching " + dir);
  };

  error = function(message, exitCode) {
    if (exitCode == null) {
      exitCode = 1;
    }
    console.log('\n  error:', message, "\n");
    return process.exit(exitCode);
  };

  success = function() {
    return process.exit(0);
  };

  usage = function(code) {
    if (code == null) {
      code = 0;
    }
    commander.help();
    return process.exit(code);
  };

  tabs = function(count) {
    return Array(count + 1).join('\t');
  };

  spaces = function(count) {
    return Array(count + 1).join(' ');
  };

  verbose = function(level, message) {
    if (commander.verbose >= level) {
      return console.log("" + (spaces(4 * (level - 1))) + message);
    }
  };

  isFile = function(filePath) {
    try {
      return (fs.statSync(filePath)).isFile();
    } catch (e) {
      return false;
    }
  };

  isDirectory = function(dirpath) {
    try {
      return (fs.statSync(dirpath)).isDirectory();
    } catch (e) {
      return false;
    }
  };

  relativePathWithEscaping = function(fullPath, relativeTo) {
    return _escapeSingleQuotes('/' + path.relative(process.cwd(), fullPath));
  };

  fullPaths = function(relativePaths, dir) {
    return _.map(relativePaths, function(p) {
      return path.join(dir, p);
    });
  };

  ls = function(paths, cb, results) {
    var breakIfDone, fullpath, pending, _fn, _i, _len;
    if (results == null) {
      results = {
        files: [],
        directories: []
      };
    }
    pending = paths.length;
    breakIfDone = function() {
      if (pending === 0) {
        results.files = _.uniq(results.files);
        results.directories = _.uniq(results.directories);
        return cb(null, results);
      }
    };
    _fn = function(fullpath) {
      return fs.stat(fullpath, function(err, stat) {
        if (stat != null ? stat.isDirectory() : void 0) {
          return fs.readdir(fullpath, function(err_, paths_) {
            if (err_) {
              return cb(err_);
            }
            results.directories.push(fullpath);
            paths_ = fullPaths(paths_, fullpath);
            return ls(paths_, (function(err3, res) {
              return breakIfDone(--pending);
            }), results);
          });
        } else {
          results.files.push(fullpath);
          return breakIfDone(--pending);
        }
      });
    };
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      fullpath = paths[_i];
      _fn(fullpath);
    }
    return breakIfDone();
  };

  readFileSync = function(filePath) {
    return fs.readFileSync(filePath, 'utf8');
  };

  _commonPath = function(moduleName, moduleParentPaths) {
    var p, _i, _len;
    if (!((moduleName != null) && _.isArray(moduleParentPaths))) {
      return null;
    }
    for (_i = 0, _len = moduleParentPaths.length; _i < _len; _i++) {
      p = moduleParentPaths[_i];
      if (_startsWith(moduleName, p + '/')) {
        return p + '/';
      }
    }
    return null;
  };

  trimArgList = function(v) {
    return _trim(v.split(','));
  };

  _trim = function(any) {
    var out;
    if (_.isString(any)) {
      return any.trim();
    } else if (_.isArray(any)) {
      out = _.map(any, function(v) {
        return v.trim();
      });
      return _.reject(out, (function(v) {
        return v === '' || v === null;
      }));
    } else {
      return any;
    }
  };

  _startsWith = function(strInput, strStart) {
    if (!((_.isString(strInput)) && (_.isString(strStart)))) {
      throw 'startsWith: argument error';
    }
    return strInput.length >= strStart.length && strInput.lastIndexOf(strStart, 0) === 0;
  };

  _escapeSingleQuotes = function(str) {
    return str.replace(/'/g, "\\'");
  };

  _insertAt = function(str, ix, substr) {
    return str.slice(0, ix) + substr + str.slice(ix);
  };

  _length = function(any) {
    return any.length || _.keys(any).length;
  };

  minifyJS = function(filename, js, options) {
    if (options == null) {
      options = {};
    }
    if (filename) {
      verbose(4, "minified " + filename);
    }
    try {
      return js = uglifyjs(js, options);
    } catch (e) {
      if (filename) {
        console.log("oj.command: could not minify: " + filename);
      }
      console.log(e);
      throw e;
    }
  };

  minifyJSUnless = function(isDebug, filename, js, options) {
    if (isDebug) {
      return js;
    }
    return minifyJS(filename, js, options);
  };

  minifySimpleJS = function(js, options) {
    if (options == null) {
      options = {};
    }
    js = js.replace(/\n/g, '');
    return js.replace(/\s\s+/g, ' ');
  };

  minifySimpleJSUnless = function(isDebug, js, options) {
    if (isDebug) {
      return js;
    }
    return minifySimpleJS(js, options);
  };

  minifyCSS = function(filename, css, structureOff) {
    if (structureOff == null) {
      structureOff = false;
    }
    if (filename) {
      verbose(4, "minified " + filename);
    }
    try {
      return css = csso.justDoIt(css, structureOff);
    } catch (e) {
      if (filename) {
        console.log("oj.command: could not minify: " + filename);
      }
      console.log(e);
      throw e;
    }
  };

  minifyCSSUnless = function(isDebug, filename, css, structureOff) {
    if (isDebug) {
      return css;
    }
    return minifyCSS(filename, css, structureOff);
  };

  _rememberModule = function(modules, filename, code, module) {
    if (code) {
      verbose(3, "found " + filename);
    }
    return modules[filename] = _.defaults({
      code: code,
      module: module
    }, modules[filename] || {});
  };

  _cacheHooks = {};

  _cacheOrigs = {};

  _hookRequire = function(modules) {
    var ext, handlers, hook, _results;
    handlers = require.extensions;
    _results = [];
    for (ext in handlers) {
      hook = _cacheHooks[ext] || (_cacheHooks[ext] = _createHook(ext, modules));
      if (handlers[ext] !== hook) {
        _cacheOrigs[ext] = handlers[ext];
        _results.push(handlers[ext] = hook);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _createHook = function(ext, modules) {
    return function(module, filename) {
      var moduleCompile;
      if (!module.loaded) {
        _rememberModule(modules, filename, null, module.paths);
        moduleCompile = module._compile;
        module._compile = function(code) {
          _rememberModule(modules, filename, code, module.paths);
          return moduleCompile.apply(this, arguments);
        };
      }
      _cacheOrigs[ext](module, filename);
      return _hookRequire(modules);
    };
  };

  _nodeModulesSupported = {
    oj: 1,
    assert: 1,
    console: 1,
    crypto: 1,
    events: 1,
    freelist: 1,
    path: 1,
    punycode: 1,
    querystring: 1,
    string_decoder: 1,
    tty: 1,
    url: 1,
    util: 1
  };

  _nodeModuleUnsupported = {
    child_process: 1,
    domain: 1,
    fs: 1,
    net: 1,
    os: 1,
    vm: 1,
    buffer: 1
  };

  isNodeModule = function(module) {
    return !!_nodeModulesSupported[module];
  };

  isUnsupportedNodeModule = function(module) {
    return !!_nodeModuleUnsupported[module];
  };

  isAppModule = function(module) {
    return (module.indexOf('/')) === -1;
  };

  isRelativeModule = function(module) {
    return (module.indexOf('/')) !== -1;
  };

  _requireCache = null;

  _saveRequireCache = function() {
    return _requireCache = _.clone(require.cache);
  };

  _restoreRequireCache = function() {
    return require.cache = _requireCache;
  };

  _clearRequireCacheRecord = function(record) {
    return delete require.cache[require.resolve(record)];
  };

  _getRequiresInSource = function(code) {
    var match, out, r;
    r = new RegExp("require\\s*\\(?\\s*[\"']([^\"']+)", 'g');
    out = [];
    while (match = r.exec(code)) {
      out.push(match[1]);
    }
    return out;
  };

  _first = function(array, fn) {
    var x, y, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      x = array[_i];
      y = fn(x);
      if (y) {
        return y;
      }
    }
  };

  _buildRequireCache = function(modules, cache) {
    var data, filename, pathComponents;
    for (filename in modules) {
      data = modules[filename];
      if (!(data.code != null)) {
        data.code = stripBOM(readFileSync(filename));
      }
      _buildFileCache(cache.files, filename, data.code, commander.debug);
      pathComponents = _first(module.parent.paths, function(prefix) {
        var moduleMain, moduleName, modulePath;
        if (_startsWith(filename, prefix + path.sep)) {
          modulePath = (filename.slice(prefix.length + 1)).split(path.sep);
          moduleName = modulePath[0];
          moduleMain = modulePath.slice(1).join(path.sep);
          return {
            modulesDir: prefix,
            moduleName: moduleName,
            moduleMain: moduleMain,
            moduleParentPath: module.id
          };
        }
      });
      if (pathComponents) {
        if (!cache.modules[pathComponents.modulesDir]) {
          cache.modules[pathComponents.modulesDir] = {};
        }
        cache.modules[pathComponents.modulesDir][pathComponents.moduleName] = pathComponents.moduleMain;
      }
      _buildNativeCache(cache["native"], data.code, commander.debug);
      verbose(3, "stored " + filename);
    }
    delete cache.files[require.resolve('oj')];
    return cache;
  };

  _buildFileCache = function(_filesCache, filename, code, isDebug) {
    return _filesCache[filename] = minifyJSUnless(isDebug, filename, code);
  };

  pass = 1;

  _buildNativeCache = function(nativeCache, code, isDebug) {
    var moduleNameList;
    moduleNameList = _getRequiresInSource(code);
    return _buildNativeCacheFromModuleList(nativeCache, moduleNameList, isDebug);
  };

  _buildNativeCacheFromModuleList = function(nativeCache, moduleNameList, isDebug) {
    var codeModule, moduleName;
    while (moduleName = moduleNameList.shift()) {
      if (nativeCache[moduleName]) {
        continue;
      }
      if (moduleName === 'oj') {
        nativeCache.oj = _ojModuleCode(isDebug);
      } else if (isUnsupportedNodeModule(moduleName)) {
        pass;

      } else if (isNodeModule(moduleName)) {
        codeModule = _nativeModuleCode(moduleName, isDebug);
        nativeCache[moduleName] = codeModule;
        moduleNameList = moduleNameList.concat(_getRequiresInSource(codeModule));
      } else {
        pass;

      }
    }
    return null;
  };

  _ojModuleCode = function(isDebug) {
    var code;
    code = readFileSync(path.join(__dirname, "../lib/oj.js"));
    return minifyJSUnless(isDebug, 'oj', code);
  };

  _nativeModuleCode = function(moduleName, isDebug) {
    var code;
    if (isDebug) {
      verbose(3, "found " + moduleName);
    }
    code = readFileSync(path.join(__dirname, "../modules/" + moduleName + ".js"));
    return minifyJSUnless(isDebug, moduleName, code);
  };

  _requireCacheToString = function(cache, isDebug) {
    var code, filePath, moduleDir, moduleName, nameToMain, _fileToString, _files, _find, _modules, _modulesToString, _native, _nativeModuleToString, _ref, _ref1, _ref2, _run;
    _modulesToString = function(moduleDir, nameToMain) {
      moduleDir = relativePathWithEscaping(moduleDir, process.cwd());
      return "M['" + moduleDir + "'] = " + (JSON.stringify(nameToMain)) + ";\n";
    };
    _nativeModuleToString = function(moduleName, code) {
      moduleName = _escapeSingleQuotes(moduleName);
      if (!code) {
        console.log("moduleName is undefined: ", moduleName);
      }
      return "F['" + moduleName + "'] = (function(module,exports){(function(require,process,global,__dirname,__filename){" + code + "})(RR('/'),P,G,'/','" + moduleName + "');});\n";
    };
    _fileToString = function(filePath, code) {
      var fileDir, fileName;
      filePath = relativePathWithEscaping(filePath, process.cwd());
      fileDir = path.dirname(filePath);
      fileName = path.basename(filePath);
      return "F['" + filePath + "'] = (function(module,exports){(function(require,process,global,__dirname,__filename){" + code + "})(RR('" + filePath + "'),P,G,'" + fileDir + "','" + fileName + "');});\n";
    };
    _modules = "";
    _ref = cache.modules;
    for (moduleDir in _ref) {
      nameToMain = _ref[moduleDir];
      _modules += _modulesToString(moduleDir, nameToMain);
    }
    _files = "";
    _ref1 = cache.files;
    for (filePath in _ref1) {
      code = _ref1[filePath];
      _files += _fileToString(filePath, code);
      verbose(3, "serialized `" + filePath + "`");
    }
    _native = "";
    _ref2 = cache["native"];
    for (moduleName in _ref2) {
      code = _ref2[moduleName];
      _native += _nativeModuleToString(moduleName, code);
      verbose(3, "serialized '" + moduleName + "'");
    }
    _run = minifySimpleJSUnless(isDebug, "function run(f) {\n  if(R[f] != null)\n    return R[f];\n  var eo = {},\n    mo = {exports: eo};\n  if(typeof F[f] != 'function')\n    throw new Error(\"file not found (\" + f + \")\");\n  F[f](mo,eo);\n  return R[f] = mo.exports;\n}");
    _find = minifySimpleJSUnless(isDebug, "function find(m,f){\n  var r, p, dir, dm, ext, ex, i;\n\n  if (F[m] && F[m][0] !== '/') return m;\n\n  p = require('path');\n\n  if (!!m.match(/\\//)) {\n    r = p.resolve(f, p.join(p.dirname(f), m));\n    ext = ['.oj','.coffee','.js','.json'];\n    for(i = 0; i < ext.length; i++) {\n      ex = ext[i];\n      if(F[r+ex])\n        return r+ex;\n    }\n  } else {\n    dir = p.dirname(f);\n    while(true) {\n      dm = p.join(dir, 'node_modules');\n      if(M[dm] && M[dm][m])\n        return p.join(dm, m, M[dm][m]);\n      if(dir == '/')\n        break;\n      dir = p.resolve(dir, '..');\n    }\n  }\n  throw new Error(\"module not found (\" + m + \")\");\n}");
    return "<script>\n  // oj v" + oj.version + "\n  (function(){\n    var F = {}, M = {}, R = {}, P, G, RR;\n\n    " + _modules + "\n    " + _files + "\n    " + _native + "\n\n    P = {cwd: function(){return '/';}};\n    G = {process: P,Buffer: {}};\n\n    RR = function(f){\n      return function(m){return run(find(m, f));};\n      " + _run + "\n      " + _find + "\n    }\n\n    require = RR('/');\n    oj = require('oj');\n\n  }).call(this);\n</script>";
  };

}).call(this);
