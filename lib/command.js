// Generated by CoffeeScript 1.3.3
(function() {
  var coffee, commander, compile, error, fs, isAppModule, isDirectory, isFile, isNodeModule, isRelativeModule, isUnsupportedNodeModule, minifyCSS, minifyJS, nodeModuleUnsupported, nodeModulesSupported, oj, path, success, trimArgList, uglifyjs, vm, watch, _, _buildCache, _cache, _cacheHooks, _cacheOrigs, _cacheToString, _clearRequireCache, _createHook, _first, _getRequiresInSource, _hookRequire, _nativeModuleCode, _remember, _remembered;

  vm = require('vm');

  commander = require('commander');

  fs = require('fs');

  coffee = require('coffee-script');

  oj = require('./oj');

  uglifyjs = require('uglify-js');

  path = require('path');

  _ = require('underscore');

  module.exports = function() {
    var cacheString, crypto, dirType, dirTypeOption, filePath, ix, _commonPath, _i, _j, _len, _len1, _ref, _ref1;
    commander.version('0.0.5').usage('[options] <file, ...>').option('-o, --output <dir>', 'Directory to output all files to (default: .)', process.cwd()).option('-w, --watch <dir,dir,...>', 'Directories to watch (default: off)', trimArgList).option('-d, --debug', 'Turn on debug output (default: false)', false).option('-r, --recurse', 'Recurse into directories (default: off)', false).option('-v, --verbose', 'Turn on verbose output (default: off)').parse(process.argv);
    if (!isDirectory(commander.output)) {
      error("directory expected for --output option (" + commander.output + ")");
    }
    dirTypeOption = ['--output-css', '--output-js', '--output-html'];
    _ref = ['outputCss', 'outputJs', 'outputHtml'];
    for (ix = _i = 0, _len = _ref.length; _i < _len; ix = ++_i) {
      dirType = _ref[ix];
      if (!commander[dirType]) {
        commander[dirType] = commander.output;
      }
      if (!isDirectory(commander[dirType])) {
        error("directory expected at " + dirTypeOption[ix] + " option (" + commander[dirType] + ")");
      }
    }
    commander.files = commander.args;
    if (!_.isArray(commander.files) || commander.files.length === 0) {
      error('expecting one or more files');
    }
    _commonPath = function(moduleName, moduleParentPaths) {
      var p, _j, _len1;
      if (!((moduleName != null) && _.isArray(moduleParentPaths))) {
        return null;
      }
      for (_j = 0, _len1 = moduleParentPaths.length; _j < _len1; _j++) {
        p = moduleParentPaths[_j];
        if (_.startsWith(moduleName, p + '/')) {
          return p + '/';
        }
      }
      return null;
    };
    _hookRequire();
    crypto = require('crypto');
    _ref1 = commander.files;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      filePath = _ref1[_j];
      require(path.join(process.cwd(), filePath));
    }
    cacheString = _cacheToString(_buildCache(_remembered));
    return fs.writeFileSync('output.js', cacheString);
  };

  compile = function(fileList, options) {
    if (options == null) {
      options = {};
    }
  };

  watch = function(directories, options) {
    if (options == null) {
      options = {};
    }
    return console.log("watch called: (NYI)");
  };

  error = function(message, exitCode) {
    if (exitCode == null) {
      exitCode = 1;
    }
    console.log('oj: ', message);
    return process.exit(exitCode);
  };

  success = function(message) {
    return error(message, 0);
  };

  isFile = function(filepath) {
    try {
      return (fs.statSync(filepath)).isFile();
    } catch (e) {
      return false;
    }
  };

  isDirectory = function(dirpath) {
    try {
      return (fs.statSync(dirpath)).isDirectory();
    } catch (e) {
      return false;
    }
  };

  trimArgList = function(v) {
    return _.trim(v.split(','));
  };

  _.trim = function(any) {
    var out;
    if (_.isString(any)) {
      return any.trim();
    } else if (_.isArray(any)) {
      out = _.map(any, function(v) {
        return v.trim();
      });
      return _.reject(out, (function(v) {
        return v === '' || v === null;
      }));
    } else {
      return any;
    }
  };

  _.startsWith = function(strInput, strStart) {
    if (!((_.isString(strInput)) && (_.isString(strStart)))) {
      throw 'startsWith: argument error';
    }
    return strInput.length >= strStart.length && strInput.lastIndexOf(strStart, 0) === 0;
  };

  _.escapeSingleQuotes = function(str) {
    return str.replace(/'/g, "\\'");
  };

  minifyJS = function(js, options) {
    if (options == null) {
      options = {};
    }
    return uglifyjs(js, options);
  };

  minifyCSS = function(css, structureOff) {
    if (structureOff == null) {
      structureOff = false;
    }
    return require('csso').justDoIt(css, structureOff);
  };

  _remembered = {};

  _remember = function(filename, code, module) {
    return _remembered[filename] = _.defaults({
      code: code,
      module: module
    }, _remembered[filename] || {});
  };

  _cacheHooks = {};

  _cacheOrigs = {};

  _hookRequire = function() {
    var ext, handlers, hook, _results;
    handlers = require.extensions;
    _results = [];
    for (ext in handlers) {
      hook = _cacheHooks[ext] || (_cacheHooks[ext] = _createHook(ext));
      if (handlers[ext] !== hook) {
        _cacheOrigs[ext] = handlers[ext];
        _results.push(handlers[ext] = hook);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _createHook = function(ext) {
    return function(module, filename) {
      var moduleCompile;
      if (!module.loaded) {
        _remember(filename, null, module.paths);
        moduleCompile = module._compile;
        module._compile = function(code) {
          _remember(filename, code, module.paths);
          return moduleCompile.apply(this, arguments);
        };
      }
      _cacheOrigs[ext](module, filename);
      return _hookRequire();
    };
  };

  nodeModulesSupported = {
    assert: 1,
    console: 1,
    crypto: 1,
    events: 1,
    freelist: 1,
    path: 1,
    punycode: 1,
    string_decoder: 1,
    url: 1,
    util: 1
  };

  nodeModuleUnsupported = {
    fs: 1,
    vm: 1,
    net: 1,
    os: 1,
    tty: 1
  };

  isNodeModule = function(module) {
    return !!nodeModulesSupported[module];
  };

  isUnsupportedNodeModule = function(module) {
    return !!nodeModuleUnsupported[module];
  };

  isAppModule = function(module) {
    return (module.indexOf('/')) === -1;
  };

  isRelativeModule = function(module) {
    return (module.indexOf('/')) !== -1;
  };

  _clearRequireCache = function() {};

  _getRequiresInSource = function(code) {
    var match, out, r;
    r = new RegExp("require\\s*\\(?\\s*[\"']([^\"']+)", 'g');
    out = [];
    while (match = r.exec(code)) {
      out.push(match[1]);
    }
    return out;
  };

  _first = function(array, fn) {
    var x, y, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      x = array[_i];
      y = fn(x);
      if (y) {
        return y;
      }
    }
  };

  _cache = {
    modules: {},
    files: {}
  };

  _buildCache = function(remembered) {
    var data, filename, moduleName, moduleNameList, pathComponents, _i, _len;
    for (filename in remembered) {
      data = remembered[filename];
      if (!(data.code != null)) {
        data.code = stripBOM(fs.readFileSync(filename, 'utf8'));
      }
      if (!commander.debug) {
        try {
          data.code = minifyJS(data.code);
        } catch (e) {
          console.log("oj.command: could not minify: " + filename);
          console.log(e);
          throw e;
        }
      }
      _cache.files[filename] = data.code;
      pathComponents = _first(module.parent.paths, function(prefix) {
        var moduleMain, moduleName, modulePath;
        if (_.startsWith(filename, prefix + path.sep)) {
          modulePath = (filename.slice(prefix.length + 1)).split(path.sep);
          moduleName = modulePath[0];
          moduleMain = modulePath.slice(1).join(path.sep);
          return {
            modulesDir: prefix,
            moduleName: moduleName,
            moduleMain: moduleMain,
            moduleParentPath: module.id
          };
        }
      });
      if (pathComponents) {
        if (!_cache.modules[pathComponents.modulesDir]) {
          _cache.modules[pathComponents.modulesDir] = {};
        }
        _cache.modules[pathComponents.modulesDir][pathComponents.moduleName] = pathComponents.moduleMain;
      }
      moduleNameList = _getRequiresInSource(data.code);
      for (_i = 0, _len = moduleNameList.length; _i < _len; _i++) {
        moduleName = moduleNameList[_i];
        if (isUnsupportedNodeModule(moduleName)) {
          throw "oj.command: requiring an unsupported native module (" + moduleName + ") in file (" + filename + ")";
        } else if (isNodeModule(moduleName)) {
          _cache["native"][moduleName] = _nativeModuleCode(moduleName);
        }
      }
    }
    return _cache;
  };

  _cacheToString = function(cache) {
    var code, filename, initialFile, moduleDir, moduleMain, moduleName, nameToMain, output, _fileToString, _moduleToString, _ref, _ref1;
    initialFile = path.join(process.cwd(), "__index__");
    _fileToString = function(filename, code) {
      filename = _.escapeSingleQuotes(filename);
      return "F['" + filename + "'] = (function(require, module){" + code + "})(requirer('" + filename + "'), module);\n";
    };
    _moduleToString = function(moduleDir, moduleName, moduleMain) {
      moduleDir = _.escapeSingleQuotes(moduleDir);
      moduleName = _.escapeSingleQuotes(moduleName);
      moduleMain = _.escapeSingleQuotes(moduleMain);
      return "M['" + moduleDir + "'] = {'" + moduleName + "': '" + moduleMain + "'};\n";
    };
    output = "// oj v" + oj.version + "\n(function(){\nvar F = {}, M = {}, N = {};\n\nfunction resolve(m, f) {\n  var dir = path.dirname(f);\n\n  // Relative\n  if(!!m.match(/\\//)){\n    return path.join(dir, m);\n  }\n\n  // Native\n  else if (N[m]){\n     return N[m];\n  }\n\n  // App\n  //else {\n  //}\n}\n\nfunction requirer(file){\n  return function(module){\n    r = resolve(module, file);\n  };\n}\n";
    _ref = cache.modules;
    for (moduleDir in _ref) {
      nameToMain = _ref[moduleDir];
      for (moduleName in nameToMain) {
        moduleMain = nameToMain[moduleName];
        output += _moduleToString(moduleDir, moduleName, moduleMain);
      }
    }
    _ref1 = cache.files;
    for (filename in _ref1) {
      code = _ref1[filename];
      output += _fileToString(filename, code);
    }
    output += "\nwindow.require = requirer(" + initialFile + ");\nwindow.oj = require('oj');\n}).call(this);\n";
    return output;
  };

  _nativeModuleCode = function(moduleName) {};

}).call(this);
