// Generated by CoffeeScript 1.3.3
(function() {
  var cacheModuleDirFromFileDir, coffee, commander, compile, error, fs, includer, isDir, isDirectory, isFile, moduleMain, modulesDirFromFileDir, oj, path, registerOJExtension, requireAndPrint, success, trimArgList, vm, watch, _;

  _ = require('underscore');

  commander = require('commander');

  path = require('path');

  fs = require('fs');

  vm = require('vm');

  oj = require('./oj');

  includer = require('./includer');

  coffee = require('coffee-script');

  module.exports = function() {
    var dirType, dirTypeOption, filePath, ix, _i, _j, _len, _len1, _ref, _ref1, _results;
    commander.version('0.0.3').usage('[options] <file, ...>').option('-o, --output <dir>', 'Directory to output all files to (default: .)', process.cwd()).option('    --css <dir>', 'Directory to output css files to (default: .)').option('    --js <dir>', 'Directory to output js files to (default: .)').option('    --html <dir>', 'Directory to output css files to (default: .)').option('-r, --recurse', 'Recurse into directories (default: off)', false).option('-w, --watch <dir,dir,...>', 'Directories to watch (default: off)', trimArgList).option('-v, --verbose', 'Turn on verbose output (default: off)').parse(process.argv);
    if (!isDirectory(commander.output)) {
      error("directory expected for --output option (" + commander.output + ")");
    }
    dirTypeOption = ['--output-css', '--output-js', '--output-html'];
    _ref = ['outputCss', 'outputJs', 'outputHtml'];
    for (ix = _i = 0, _len = _ref.length; _i < _len; ix = ++_i) {
      dirType = _ref[ix];
      if (!commander[dirType]) {
        commander[dirType] = commander.output;
      }
      if (!isDirectory(commander[dirType])) {
        error("directory expected at " + dirTypeOption[ix] + " option (" + commander[dirType] + ")");
      }
    }
    commander.files = commander.args;
    if (!_.isArray(commander.files) || commander.files.length === 0) {
      error('expecting one or more files');
    }
    console.log("commander.files: ", commander.files);
    _ref1 = commander.files;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      filePath = _ref1[_j];
      _results.push(compile(filePath));
    }
    return _results;
  };

  compile = function(file, options) {
    var directory, fullPath, include, isAppModule, isNodeModule, isRelativeModule, isUnsupportedNodeModule, nodeModuleUnsupported, nodeModules, wrap, wrapper;
    if (options == null) {
      options = {};
    }
    nodeModules = ['assert', 'console', 'crypto', 'events', 'freelist', 'path', 'punycode', 'string_decoder', 'url', 'util'];
    nodeModuleUnsupported = ['fs', 'vm', 'net', 'os', 'tty'];
    isNodeModule = function(module) {
      return (_.indexOf(nodeModules, module)) !== -1;
    };
    isUnsupportedNodeModule = function(module) {
      return (_.indexOf(nodeModuleUnsupported, module)) !== -1;
    };
    isAppModule = function(module) {
      return (module.indexOf('/')) === -1;
    };
    isRelativeModule = function(module) {
      return (module.indexOf('/')) !== -1;
    };
    wrapper = ['(function (exports, require, module, __filename, __dirname) {\n ', '\n});'];
    wrap = function(source) {
      return wrapper[0] + source + wrapper[1];
    };
    console.log("compile called with options: ", options);
    fullPath = path.resolve(file);
    if (!isFile(fullPath)) {
      error("file not found (" + fullPath + ")");
    }
    directory = path.dirname(fullPath);
    include = includer(directory);
    return fs.readFile(fullPath, 'utf8', function(err, code) {
      var fn, newExports, newModule, scope, scopedOJ, scopedRequire;
      if (err) {
        throw new Error(err);
      }
      try {
        code = coffee.compile(code);
      } catch (e) {

      }
      scopedOJ = _.extend({}, oj, {
        include: include
      });
      scope = _.extend({}, global, scopedOJ, {
        oj: scopedOJ
      });
      scopedRequire = function(modulePath) {
        if (isUnsupportedNodeModule(modulePath)) {
          throw new Error('oj.compile: #{modulePath} module is unsupported in oj files');
        } else if (isNodeModule(modulePath)) {
          console.log("node module found: ", modulePath);
          return requireAndPrint(modulePath);
        } else if (isRelativeModule(modulePath)) {
          console.log("relative module found: ", modulePath);
          return requireAndPrint(path.join(directory, modulePath));
        } else if (isAppModule(modulePath)) {
          console.log("app module found: ", modulePath);
          return requireAndPrint(moduleMain(directory, modulePath));
        }
      };
      fn = vm.runInContext(wrap(code), vm.createContext(scope), fullPath);
      newExports = {};
      newModule = {
        exports: newExports
      };
      fn(newExports, scopedRequire, newModule, fullPath, directory);
      return console.log("newModule: ", newModule);
    });
  };

  moduleMain = function(dir, reference) {
    var json, main, moduleDir, moduleDirPackage, modulesDir;
    modulesDir = modulesDirFromFileDir(dir);
    if (modulesDir == null) {
      throw new Error("oj.compile: app directory not found above ${dir}");
    }
    moduleDir = path.join(modulesDir, reference);
    console.log("moduleDir: ", moduleDir);
    moduleDirPackage = path.join(moduleDir, 'package.json');
    console.log("moduleDirPackage: ", moduleDirPackage);
    try {
      json = fs.readFileSync(moduleDirPackage);
      console.log("package: ", json);
      main = (JSON.parse(json)).main;
      console.log("main: ", main);
      console.log("path.join moduleDir, main: ", path.join(moduleDir, main));
      return path.join(moduleDir, main);
    } catch (e) {
      throw new Error("oj.compile: package.json not found (" + e + ")");
    }
  };

  isDir = function(dir) {
    var stat;
    try {
      stat = fs.statSync(dir);
      return stat.isDirectory();
    } catch (e) {

    }
    return false;
  };

  registerOJExtension = function() {
    if (require.extensions) {
      return require.extensions['.oj'] = function(module, filename) {
        var content;
        console.log("registering .oj extension");
        content = compileFile(filename);
        return module._compile(content, filename);
      };
    }
  };

  requireAndPrint = function(module) {
    console.log("requiring: ", module);
    return require(module);
  };

  cacheModuleDirFromFileDir = {};

  modulesDirFromFileDir = function(dir) {
    var appDir, modulesDir, parentDir;
    console.log("modulesDirFromFileDir dir: ", dir);
    if (cacheModuleDirFromFileDir[dir] != null) {
      console.log("dir found in cache");
      return cacheModuleDirFromFileDir[dir];
    }
    appDir = dir;
    while (true) {
      console.log("searching " + appDir);
      if ((path.basename(appDir)) === 'node_modules') {
        console.log("failure: at node_modules (" + appDir + ")");
        return null;
      }
      modulesDir = path.join(appDir, 'node_modules');
      if (isDir(modulesDir)) {
        console.log("success: found appDir " + appDir);
        console.log("success: found modulesDir " + modulesDir);
        cacheModuleDirFromFileDir[dir] = modulesDir;
        return modulesDir;
      }
      parentDir = path.dirname(appDir);
      if (parentDir === appDir) {
        console.log("success: at root " + appDir);
      }
      appDir = parentDir;
    }
  };

  watch = function(directories, options) {
    if (options == null) {
      options = {};
    }
    return console.log("watch called: (NYI)");
  };

  error = function(message, exitCode) {
    if (exitCode == null) {
      exitCode = 1;
    }
    console.log('oj: ', message);
    return process.exit(exitCode);
  };

  success = function(message) {
    return error(message, 0);
  };

  isFile = function(path) {
    try {
      return (fs.statSync(path)).isFile();
    } catch (e) {
      return false;
    }
  };

  isDirectory = function(path) {
    try {
      return (fs.statSync(path)).isDirectory();
    } catch (e) {
      return false;
    }
  };

  trimArgList = function(v) {
    return _.trim(v.split(','));
  };

  _.trim = function(any) {
    var out;
    if (_.isString(any)) {
      return any.trim();
    } else if (_.isArray(any)) {
      out = _.map(any, function(v) {
        return v.trim();
      });
      return _.reject(out, (function(v) {
        return v === '' || v === null;
      }));
    } else {
      return any;
    }
  };

}).call(this);
