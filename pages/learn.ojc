
_plugins = require './_plugins'
siteCSS = require './_styles'
_template = require './_template'

{renderTOC, renderContent, renderProperties:properties, renderMethods:methods, renderEvents:events, renderInherits:inherits, renderOptions:options, renderArguments:arguments_,renderName:name} = require './_content'

md = markdown

module.exports = ->

  _template

    title: 'Learn OJ - Unified templating'

    styles: [
      'reset.css'
      'gg.css'

    ]
    scripts: [
      'jquery.js'
      'jquery.event.drag.js'
      'jquery.ba-resize.min.js'
      'underscore.js'
      'backbone.js'
      'coffee-script.js'
      'ace/ace.js'
    ]

    content: ->
      renderContent data

    toc: ->
      renderTOC data

data = [

  h: 'The High Level', id: 'crash-course', d: ->
      md """
        OJ stands for *Object JavaScript*. It is a JavaScript library with a singular goal: to make objects that encapsulate website **creation** and **manipulation**.
      """
    items: [

      h: 'Creation', id: 'creation', d: ->

        md """
          When making a website you usually must keep track of three separate concepts: HTML structure, CSS design, and JS interaction. In OJ, these concepts still exist but they are all unified into objects. OJ objects do all three; they generate their own HTML, CSS, and JS code.

          The benefit is OJ objects have no dependencies. There is no need to read the docs to be sure the HTML is correct, or the CSS is included. Everything just works.

          Allow me to demonstrate: In this example, the [oj.Button](docs.html#Button) generates its own `<button>` tag, and then once created binds a JavaScript click event:
        """

        TryEditor js: """
          // Create a button
          oj.Button('Click me', {
            click:function(){
              alert('Events work!');
            }
          });
        """, cs: """
        """
        md """
          **Go ahead. Click the button. All the examples are live compiling!**

        """
    ,
      h: 'Manipulation', id: 'manipulation', d: ->
        md """

          OK, imagine you created a website with these OJ **building blocks**. Now what? Well you probably want to change things.

          In OJ, direct DOM manipulation is built into the objects themselves. The *very same* object you used to create the website will remember its root DOM element and provide methods and properties to change itself.

          In this example, the [BulletList](docs.html#BulletList) object generates its own `<ul>` and `<li>` tags. Then the [Button](docs.html#Button) object, when clicked, adds new items to the list.
        """

        TryEditor js: """
            // Create a bulleted list
            var myList = BulletList(
              'Item 1',
              'Item 2',
              'Item 3'
            );

            // Create a button to add items
            Button('Add Item',{click:function(){
              myList.push('New Item!')
            }});
          """, cs: """
            # Create a bulleted list
            myList = BulletList(
              'Item 1'
              'Item 2'
              'Item 3'
            )

            # Create a button to add items
            Button 'Add Item', click:->
              myList.push 'New Item!'

          """
        md """
          ** What are you waiting for? Click the button!**
        """
    ,
      h: 'The Dream', id: 'the-dream', d: ->

        md """

          The dream is that your code will just work. Objects will have no dependencies and will encapsulate away the way they look (HTML/CSS) and behave (JavaScript).

          The dream is that your code will be much easier to write and maintain. Use the built-in objects or make your own. We are all making the same components and it is time to easily share them.

          The dream is you won't have to remember obscure HTML syntax. Do you really want to know that in `<table>` tags `<tfoot>` tags *must* come before `<tbody>`. The [Table](docs.html#Table) object understands this so you don't have to.

          The dream is that the same code works on the server and client. With Node.js you can build your site on the Server command-line, and the very same code will work dynamically on the client. All examples work in both.

          The dream is together we can abstract everything away. OJ is [open source](https://github.com/ojjs/oj), and there are a [growing collection of plugins](plugins.html) to build upon.

          The dream is this is just the beginning.

        """
    # ,
    #   h: 'The Editor is Live!', id: 'live-editor', d: ->

    #     md """

    #       Many people miss this the first time through. The code examples are live compiling OJ. Change stuff and it will update automatically.

    #       Go ahead, edit away:

    #     """

    #     TryEditor lineCount: 4, js:"""
    #         // Create a paragraph
    #         p("Edit me, I'm editable...");
    #       """, cs:"""
    #         # Create a paragraph
    #         p "Edit me, I'm editable..."
    #       """
    #     md """
    #       In addition, the editor allows you to switch between JavaScript (js) and CoffeeScript (cs) compiling. OJ was designed work well in either. No pressure, either way. We all have difference preferences and OJ will always work in pure JavaScript.
    #     """
    # ,
    #   h: 'The jQuery Dependency', id: 'live-editor', d: ->

    #     md """

    #       Now you may say. "That is nice and all, but why should I care because jQuery can do this?" Well, you are right. jQuery *can* do it quite well; in fact OJ depends on jQuery 2.0 for this very reason. OJ uses jQuery selectors, DOM manipulation, and event binding to ensure this stuff works cross-platform.

    #       As you probably know, jQuery 2.0 is the version of jQuery made for "modern" browsers, specifically IE9 and above. It took a lot of soul searching, but this version requirement also holds for OJ. The reason is primarily to allow OJ objects to use first-class properties (a feature that works IE9+). For example CheckBox values can be set with assignment instead of a function call
    #     """

    #     TryEditor js: """
    #         // Define a checkbox
    #         var cb = CheckBox(true, {click:
    #           function(){
    #             cb.$el.ojAfter(function(){
    #               div('The value is ' + cb.value);
    #             });
    #           }
    #         });

    #         // value is a smart property
    #         // that updates the DOM live
    #         // and triggers model changes.
    #         cb.value = true;
    #     """, cs:"""
    #     """

    ]
 ,
  h: 'The Low Level', id: 'the-basics', d: ->
    md """
      Now it may seem like OJ objects are doing a lot of magic. Let me assure you they are pretty elegant. Let's start from the beginning and see how they are made.
    """
  items: [
      h: 'HTML Tags', id: 'html-tags', d: ->

        md """
          Every html `<tag>` has an analogous tag function by the same name. For example, `<div>` has:
        """
        TryEditor lineCount:2, js: """
            oj.div('This is a div');
          """

        md """Attributes are just `Object` arguments. This defines an `href` attributes on an anchor tag:"""
        TryEditor js: """
            a('Link to oj.js',
              {href:'http://ojjs.org'});
          """, cs:"""
          """

        md """Order doesn't matter for attributes. Add as many as you need and the attribute objects will be unioned. For example, this `<div>` has both an id and an inline style:"""
        TryEditor js: """
            div({id:"id-42"},
              'A div with id and style',
              {style:"color:purple"});
          """, cs:"""
          """

        md """To make life easier, style attributes can be set with objects and support `camelCase` in addition to `dashed-case`:"""
        TryEditor js: """
            div('A div with styling', {
              style:{
                color:'green',
                fontSize:'30px'
              }
            });
          """, cs:"""
          """
    ,
      h: 'CSS Styles', id: 'css-styles', d: ->

        md """
          Like tag functions, css is defined by its own function `oj.css`. It accepts an object of objects:
        """

        TryEditor js:"""
            css({
              'div':{
                color:'red'
            }});

            div('This div is red');
          """, cs:"""
          """

        md """
          The css function fully supports selectors. You can select classes:
        """
        TryEditor js:"""
            css({
              '.big':{
                fontSize:'25px'
            }});

            div({'class':'big'},
              'This div is big');
          """, cs:"""
          """
    ,
      h: 'JS Events', id: 'js-events', d: ->




        # p 'OK, great. We have a list, but now I want to live edit it. Say I want to add more items or change the order of those items. In OJ, objects not only can create themselves but once made they can edit themselves too:'

        # TryEditor
        #   js: """
        #     var myList = BulletList(0,1,2);

        #     Button('Add Item', {
        #       click: function(){
        #         myList.push('Item added!');
        #       }
        #     });

        #     Button('Move First Item', {
        #       click: function(){
        #         myList.move(0, myList.count-1)
        #       }
        #     });
        #   """


        # md """
        #   Above we create a [BulletList](docs.html#BulletList) object with three items (0,1,2) and assign it to the value `myList`. This is not just a function but is actually a constructor that returns a new [BulletList](docs.html#BulletList) instance. Next we add a [Button](docs.html#Button) that when clicked creates a new List item.

        #   Try clicking the button. The click event is bound for you. Try switching between JS (JavaScript) and CS (Coffee-Script). The OJ library was designed to work well in both.

        #   Finally the third button uses the built in [List.move](docs.html#List-move) function to move the first item to the end of the list.
        # """

    # ,
    #   h: 'Dependencies', id: 'dependencies', d: ->
    #     md """

    #       Now you may say. "That is nice and all, but why should I care because jQuery can do this?" Well, you are right. jQuery *can* do it quite well; in fact OJ depends on jQuery 2.0 for this very reason. OJ uses jQuery selectors, DOM manipulation, and event binding to ensure this stuff works cross-platform.

    #       As you probably know, jQuery 2.0 is the version of jQuery made for "modern" browsers, specifically IE9 and above. It took a lot of soul searching, but this version requirement also holds for OJ. The reason is primarily to allow OJ objects to use first-class properties (a feature that works IE9+). For example CheckBox values can be set with assignment instead of a function call:

    #     """
    #     TryEditor
    #       js: """
    #         // Define a checkbox
    #         var cb = CheckBox(true, {click:
    #           function(){
    #             cb.$el.ojAfter(function(){
    #               div('The value is ' + cb.value);
    #             });
    #           }
    #         });

    #         // value is a smart property
    #         // that updates the DOM live
    #         // and triggers model changes.
    #         cb.value = true;
    #     """
      ]

  ,
    h: 'Partials & Templates', id: 'partials-and-templates', d: ->
      md """

      """
    items: [
      h: 'Partials', id: 'partials', d: ->
    ,
      h: 'Templates', id: 'templates', d: ->

    ]
  ,
    h: 'Model Binding', id: 'models-and-collections', d: ->
      md """

      """
    items: [

      h: 'Form Binding', id: 'form-binding', d: ->

        md """
          OJ was originally meant to be framework agnostic in the way Backbone is. At its heart OJ is about creating really powerful Views, in the MVC sense. It doesn't create Models. It doesn't create Controllers or Routing or page navigation. Instead it tries to do only one thing well: making views with objects.

          This is all still true. OJ makes Views. Period. The only compromise is OJ now can recognize and bind to Backbone-like models and collections (anything that supports the on,off,trigger event syntax). In a sense, OJ is the View to Backbones Model.

          When Backbone was originally conceived it brilliantly left Views as an exercise to the reader. The thing is there were too many ways to do templating. Back in 2010 they couldn't know which would stick. Models were a big deal, and Backbone was intended to abstract what could be abstracted well and leave the rest for later.

        """
        TryEditor
          js: """
            // Define backbone User model
            var User = Backbone.Model.extend();

            // Create a user model
            user = new User({name:'Thomas'});

            // Define TextBox bound to the model
            TextBox({model:user, key:'name'});

            // Define a TextArea bound to the model
            TextArea({model:user, key:'name'});

            // Define css to make them align
            css({'textarea, input':{
              width: 200,
              margin: 10,
              display:'block',
              border: '1px solid red'
            }});

          """
          cs: """

          """
        p (->
          md """(Since they are bound to the same model, typing in one box changes the other. Try it!)"""), style: textAlign: 'center'

    ]

  ,
    h: 'Creating Plugins', id: 'creating-plugins', d: ->
      md """

      """
    items: [

      h: 'Type System', id: 'type-system', d: ->

        md """

          The built-in objects seem pretty powerful. How hard is it to make your own?*

          Answer: Insanely easy. Making types is what OJ does!

          Included in OJ is a sophisticated type system inspired by the CoffeeScript type system. This lets you create types with:

          * Constructors
          * Single inheritance
          * Methods and Properties
          * Static Methods and Properties

          That said, OJ types have two big differences from CoffeeScript types:

          1.  OJ types work in JavaScript (CoffeeScript types only work in CoffeeScript)

              This is the big reason why OJ doesn't just use CoffeeScript types (they are pretty great). OJ needed to work in pure JavaScript and keep the syntax as clean as possible.

          2.  OJ types directly support first-class properties. So if you choose, you can define properties with get / set methods to better abstract your data access.

              This brings front and center my favorite "new" feature of JavaScript, [first-class properties (ejohn.org)](http://ejohn.org/blog/ecmascript-5-objects-and-properties/). Even though properties have been in JavaScript since 2009, most still aren't aware of them. OJ builds these kind of properties right in.

          As an example of the type system, lets create a Rectangle type that has properties `width` and `height`. Then a readonly property `area` is calculated from width and height:

        """

        TryEditor js:"""
          // Create Rectangle type
          var Rectangle = createType(
            'Rectangle', {

            // Construct with width and height
            constructor: function(w,h){
              this.width = w;
              this.height = h;
            },

            // Create properties
            properties: {
              width:null,
              height:null,

              // Area from width and height
              area: {
                get: function(){
                  return this.width *
                    this.height;
                }
              }
            }
          });

          // Instance it with new
          var myRect = new Rectangle(10,20);

          // Display the properties
          div('The width is: ', myRect.width);
          div('The height is: ', myRect.height);
          div('The area is: ', myRect.area);
          div(JSON.stringify(myRect));
        """, cs: """
        """
    ,
      h: 'Creating Views', id: 'creating-views', d: ->

        md """

          *Ok, cool. I get that OJ makes types, but do we make types that generate HTML, CSS, and JavaScript?*

          Think of OJ objects as Views in the MVC sense. OJ does not include models or routes like other frameworks. The goal is to create the best View abstraction possible in pure JavaScript and leave the rest to other frameworks.

          In a way this approach is the inverse of Backbone. Backbone has models, collection and routes. OJ just is the view. This made it a natural fit to have Backbone support built in, but an adapter to any framework would be straightforward.

          *Enough talk. How do I make a View?*

          In this example a new view is created called `OrangeButton`. This view contains default styling with CSS, and editing the `label` property will change its text.

        """

        TryEditor js:"""
          // Create an OrangeButton view
          var OrangeButton = oj.createType(
            'OrangeButton', {

            // Inherit from oj.View
            base:View,

            // Construct by setting el
            constructor: function(text, options){

              // Set root element
              this.el = oj(function(){
                button();
              });

              // Call super's constructor
              OrangeButton.base.constructor.call(
                this, options);

              // Init the label from arguments
              this.label = text;
            },

            // Create the label property
            // to get/set the button's text
            properties: {
              label: {
                get:function(){
                  return this.$el.html();
                },
                set:function(v){
                  this.$el.html(v);
                }
              }
           }
          });

          // Define CSS for this object
          OrangeButton.css({
            border:'1px solid orange',
            borderRadius: '8px',
            backgroundColor: 'white',
            '&:hover': {
              border:'1px solid red'
            }
          });

          // Create an orange button
          var myButton = OrangeButton(
            'Click My Orange Button...', {
            click: function(){
              myButton.label += ' (Woot!)';
            }
          });
        """

    ]



]